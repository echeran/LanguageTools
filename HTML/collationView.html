<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>

  <title>{{language}} collation tests</title>

  <!-- Font encoding areas -->
  <style>
    {% for encoding in langInfo.encoding_font_list %}
    @font-face{
      font-family:'{{encoding.font_name}}';
      src:url('{{encoding.font_path}}');
      font-weight:normal;
      font-style:normal;
      font-size: 32px;
    }
    .{{encoding.font_name}} {
      font-family:{{encoding.font_name}};
      font-size: 32px;
    }
    {% endfor %}
  </style>
  <!-- Unicode fonts -->
  <style>
    {% for font in langInfo.unicode_font_list %}
    @font-face{
      font-family:'{{font.family}}';
      src:url('{{font.source}}');
      font-weight:normal;
      font-style:normal;
      font-size: 16px;
    }

    .{{font.family}} {
      font-family:{{font.family}};
      font-size: 16px;
    }
    {% endfor %}
  </style>

  <style>
    table {
      border-collapse: collapse;
    }

    table, th, td {
      border: 1px solid black;
    }
    td {
    text-align: center;
    width: 120px;
    font-size:20px;
    }
  </style>

  <script src="/js/utils.js"></script>

  <script>
  var k = { loadme: Object};
  k.loadme.prototype = function(a) {
  return a;
  }
  var e = {keyboard: k};
  var google = {elements: e};
  </script>

  {% for kb in kb_list %}
  <!-- {{kb.shortName}} -->
  <script src="/layouts/{{kb.shortName}}.js"></script>
  {% endfor %}

  <script>
  {% for kb in kb_list %}
  const {{kb.shortName}}_transform =  {{kb.shortName}}.transform;
  {% endfor %}

// Keep for reset.
var original_text = "";
var original_split_text = "";
var column_headings = [];
var table_data = {};  // global object for information

const readCollationTestData = async file => {
    const response = await fetch(file)
    const text = await response.text();

    // Record results in a global object.
    table_data['text'] = text;

    //const output = document.getElementById('collation_data');
    const output_table = document.getElementById('collation_table');
    // Process before putting into HTML
    var split_text = text.split("\n");
    var num_lines = split_text.length;
    //output.innerHTML = text;
    table_data['num_lines'] = num_lines;

    // Fill in and format table of entries
    var table_row = 0;
    var max_columns = 0;  // Actually set when header row is found.
    var header_count = 0;
    for (var line = 0; line < num_lines; line ++) {
      var row = output_table.insertRow(table_row);
      var line_content = split_text[line].trim();
      if (line_content [0] != "#" && line_content.length > 0) {
        table_row += 1;
        var row_entries = line_content.split("\t");
        if (line_content[0] == "!") {
          // Header row.
          max_columns = Math.max(max_columns, row_entries.length);
          header_count += 1;
          line_content[0] = '';
          for (var col = 0; col < row_entries.length; col ++) {
            var headerCell = document.createElement("TH");
            headerCell.onclick = function(){sortTableColumn(output_table, table_data, col)};

            var col_text = row_entries[col];
            if (col_text[0] == "!") {
              col_text = col_text.substring(1);
            }
            column_headings.push(col_text);
            headerCell.innerHTML = col_text;
            row.appendChild(headerCell)
          }
        } else {
          for (var col = 0; col < Math.max(max_columns, row_entries.length); col ++) {
            var cell = row.insertCell(col);
            if (col < row_entries.length) {
              cell.innerHTML = row_entries[col];
            } else {
              cell.innerHTML = "";
            }
          }
        }
      }
    }
    original_split_text = split_text;
    original_text = text;

    table_data['column_headings'] = column_headings;
    table_data['header_count'] = header_count;
    table_data['original_split_text'] = original_split_text;
    setSortColumnMenu('setSortColumn', table_data['column_headings']);
    return text;
}

function sortTableColumn(table, table_data, sort_column) {

}

  function compare(a, b) {
    if (a > b) {
      return -1;
    }
    else if (a < b) {
      return 1;
    }
    return 0;
  }

  function sort(direction, id) {
    // TODO: sort by column contents
    var textarea = document.getElementById(id);
    if (direction == 1) {
      textarea.value = textarea.value.split("\n").sort().join("\n");
    } else {
      // Reverse
      textarea.value = textarea.value.split("\n").sort(compare).join("\n");
    }
  }

  function resetText(id) {
    var textarea = document.getElementById(id);
    textarea.value = original_text;
  }

  // Function called when any manual edit is made to textarea contents.
  function noteEditing(id) {
  }

  // Global - yuck.
  var column_to_sort = 0;
  function compareRowsByColumn(a, b) {
    var atext = a['text'];
    var btext = b['text'];
    if (atext < btext) {
      return -1;
    } else if (atext > btext) {
      return 1;
    }
    return 0;
  }

  function sortTableRows(rows, table_data, sort_column) {
    // Get sort_field.
    var sort_data = [];
    for (var row_num in rows) {
      var cells_in_row = rows[row_num].cells;
      var cell_data = [];
      // Skip header cells
      var text = "";
      try {
        var cell = cells_in_row[sort_column];
        text = cells_in_row[sort_column].innerHTML;
        for (cell in cells_in_row) {
          cell_data.push(cells_in_row[cell].innerHTML);
        }
      } catch (TypeError) {
        text = "UNKNOWN";
      }
      if (row_num >= table_data['header_count']) {
        sort_data.push({'text': text,
                        'row_num': row_num,
                        'cell_data': cell_data});
      }
    }
    column_to_sort = sort_column;
    sort_data.sort(compareRowsByColumn);

    // Now refill table.
    var out_row = table_data['header_count'];
    for (var index in sort_data) {
      var source_row = sort_data[index];
      for (var col in sort_data[index]['cell_data']) {
        try {
          rows.cells[col].innerHTML = source_row['cell_data'][col].innerHTML;
        } catch (TypeError) {
          var error = 'BOGUS';
        }
      }
    }
  }

  function onSortColumnSelected(id, value) {
    // Use menu selection to sort the column of the table.
    var table = document.getElementById(id);
    var sort_column = value;
    // Get the values for sorting
    var rows = table.rows;
    sortTableRows(rows, table_data, sort_column);  // Global
  }

  function setSortColumnMenu(id, column_headings) {
    var column_headings = table_data['column_headings'];
    var menu = document.getElementById(id);
    for (var item in column_headings) {
      var option = document.createElement("option");
      option.text = column_headings[item].trim();
      option.value = item;
      menu.add(option);
    }
  }
  function onPageLoaded() {
    var text = readCollationTestData("{{collation_data.0.test_file}}");
  }

  var encoding_font_list = [
  {% for encoding in langInfo.encoding_font_list %}"{{encoding.font_name}}",{% endfor %}
  ];

var unicode_font_list = [
  {% for font in langInfo.unicode_font_list %}"{{font.family}}",{% endfor %}
  ];

  </script>
</head>


<body onload="onPageLoaded();">

  <h1>{{langInfo.Language}}: demonstrate collation of strings</h1>
  <p>
    <button onclick="sort(1, 'collation_data');">Sort strings</button>
    <button onclick="sort(-1, 'collation_data');">Reverse sort strings</button>
    <button onclick="resetText('collation_data');">Reset text</button>
    <br/>
    Sort column: <select onchange="onSortColumnSelected('collation_table', this.value)" id="setSortColumn">
    </select>
    <table id="collation_table">
    </table>
    <textarea id="collation_data" rows="10" cols="100"
              class="{{langInfo.unicode_font_list.0.family}}"
              onkeyup="noteEditing('collation_data');">

    </textarea>


</body>
</html>
